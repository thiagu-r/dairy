<div class="modal-header">
    <h5 class="modal-title" id="deliveryOrderModalTitle">Create Delivery Order</h5>
    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
</div>
<div class="modal-body">
    <form id="deliveryOrderForm" method="POST" action="{% url 'delivery:delivery-order-create' %}">
        {% csrf_token %}
        <!-- Hidden input for items data -->
        <input type="hidden" name="items_data" id="itemsData">
        <div class="row">
            <div class="col-md-6 mb-3">
                <label class="form-label">Route</label>
                <select class="form-select" name="route_id" id="routeSelect" required>
                    <option value="">Select Route</option>
                    {% for route in routes %}
                    <option value="{{ route.id }}">{{ route.name }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="col-md-6 mb-3">
                <label class="form-label">Seller</label>
                <select class="form-select" name="seller_id" id="sellerSelect" required disabled>
                    <option value="">Select Seller</option>
                </select>
            </div>
        </div>
        <div class="row">
            <div class="col-md-6 mb-3">
                <label class="form-label">Delivery Date</label>
                <input type="date" class="form-control" name="delivery_date" id="deliveryDate" required>
            </div>
            <div class="col-md-6 mb-3">
                <label class="form-label">Delivery Time</label>
                <input type="time" class="form-control" name="delivery_time" required>
            </div>
        </div>
        <div class="row">
            <div class="col-md-6 mb-3">
                <label class="form-label">Payment Method</label>
                <select class="form-select" name="payment_method" id="paymentMethod" required>
                    <option value="cash">Cash</option>
                    <option value="credit">Credit</option>
                    <option value="bank_transfer">Bank Transfer</option>
                </select>
            </div>
            <div class="col-md-6 mb-3">
                <label class="form-label">Opening Balance</label>
                <input type="text" class="form-control" id="openingBalance" name="opening_balance" readonly>
            </div>
        </div>
        <div class="mb-3">
            <label class="form-label">Notes</label>
            <textarea class="form-control" name="notes" id="notes" rows="2"></textarea>
        </div>

        <div id="orderItems">
            <h6>Order Items</h6>
            <table class="table">
                <thead>
                    <tr>
                        <th>Product</th>
                        <th>Ordered Qty</th>
                        <th>Extra Qty</th>
                        <th>Total Qty</th>
                        <th>Unit Price</th>
                        <th>Total</th>
                    </tr>
                </thead>
                <tbody id="orderItemsBody"></tbody>
            </table>
            <button type="button" class="btn btn-sm btn-primary" id="addItemBtn">Add Item</button>
        </div>

        <div class="row mt-3">
            <div class="col-md-4">
                <label class="form-label">Amount Collected</label>
                <input type="number" class="form-control" name="amount_collected" id="amountCollected" value="0" step="0.01">
            </div>
            <div class="col-md-4">
                <label class="form-label">Total Amount</label>
                <input type="text" class="form-control" id="totalAmount" name="total_price" readonly>
            </div>
            <div class="col-md-4">
                <label class="form-label">Total Balance</label>
                <input type="text" class="form-control" id="totalBalance" name="total_balance" readonly>
            </div>
        </div>

        <div class="alert alert-danger d-none" id="errorMessage"></div>
    </form>
</div>
<div class="modal-footer">
    <button type="button" class="btn btn-label-secondary" data-bs-dismiss="modal">Close</button>
    <button type="submit" class="btn btn-primary" form="deliveryOrderForm" id="submitButton">Create Order</button>
</div>


<!-- Add a new section for order items -->
<div id="orderItemsSection" style="display: none;">
    <div class="table-responsive">
        <table class="table">
            <thead>
                <tr>
                    <th>Product</th>
                    <th>Ordered Qty</th>
                    <th>Extra Qty</th>
                    <th>Total Qty</th>
                    <th>Unit Price</th>
                    <th>Total</th>
                </tr>
            </thead>
            <tbody id="orderItemsBody2"></tbody>
        </table>
    </div>

    <!-- Add Product Button is already in the form -->
</div>

<!-- Add Product Modal -->
<div class="modal fade" id="addProductModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Add Product</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label">Product</label>
                    <select class="form-select" id="productSelect"></select>
                </div>
                <div class="mb-3">
                    <label class="form-label">Quantity</label>
                    <input type="number" class="form-control" id="productQuantity" min="0" step="0.001">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" id="confirmAddProduct">Add</button>
            </div>
        </div>
    </div>
</div>

<script>
    // Global variables
    let orderItems = [];
    let availableProducts = [];
    let salesOrderId = null;

    // Function to reset the form and clear all data
    function resetForm() {
        console.log('Resetting form and clearing data');

        // Reset the form
        document.getElementById('deliveryOrderForm').reset();

        // Clear order items and available products
        orderItems = [];
        availableProducts = [];
        salesOrderId = null;

        // Hide order items section
        const orderItemsSection = document.getElementById('orderItems');
        if (orderItemsSection) {
            orderItemsSection.style.display = 'none';
        }

        // Clear the order items table
        const orderItemsBody = document.getElementById('orderItemsBody');
        if (orderItemsBody) {
            orderItemsBody.innerHTML = '';
        }

        // Reset the selects
        document.getElementById('routeSelect').selectedIndex = 0;
        document.getElementById('sellerSelect').innerHTML = '<option value="">Select Seller</option>';

        // Reset the payment fields
        document.getElementById('openingBalance').value = '0';
        document.getElementById('amountCollected').value = '0';
        document.getElementById('balanceAmount').value = '0';
        document.getElementById('totalBalance').value = '0';
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Get the modal element
        const modal = document.getElementById('createDeliveryOrderModal');

        // Add event listener for when the modal is hidden
        modal.addEventListener('hidden.bs.modal', function () {
            console.log('Modal closed, resetting form');
            resetForm();
        });

        // Add event listener for the custom setOrderItems event
        modal.addEventListener('setOrderItems', function(event) {
            console.log('Received setOrderItems event:', event.detail);
            orderItems = event.detail.items;
            updateOrderItemsTable();

            // Show the order items section inside the form
            document.getElementById('orderItems').style.display = 'block';

            // Hide the add item button in edit mode
            const addItemBtn = document.getElementById('addItemBtn');
            if (addItemBtn) {
                addItemBtn.style.display = 'none';
            }
        });

        const routeSelect = document.getElementById('routeSelect');
        const sellerSelect = document.getElementById('sellerSelect');
        const deliveryDate = document.getElementById('deliveryDate');
        // Get the order items section element
        const orderItemsSection = document.getElementById('orderItems');

        // This is now defined locally in updateOrderItemsTable
        const addItemBtn = document.getElementById('addItemBtn');
        const deliveryOrderForm = document.getElementById('deliveryOrderForm');
        const totalAmountInput = document.getElementById('totalAmount');
        const amountCollectedInput = document.getElementById('amountCollected');
        const totalBalanceInput = document.getElementById('totalBalance');

        // Use the global variables defined above
        window.orderItems = orderItems;

        // Load sellers when route is selected
        routeSelect.addEventListener('change', function() {
            const routeId = this.value;
            sellerSelect.innerHTML = '<option value="">Select Seller</option>';
            sellerSelect.disabled = true;
            orderItemsSection.style.display = 'none';

            if (routeId) {
                fetch(`/api/routes/${routeId}/sellers/`)
                    .then(response => response.json())
                    .then(data => {
                        data.sellers.forEach(seller => {
                            const option = new Option(seller.store_name, seller.id);
                            sellerSelect.add(option);
                        });
                        sellerSelect.disabled = false;
                    });
            }
        });

        // Load sales order items when seller and date are selected
        function loadOrderItems() {
            const sellerId = sellerSelect.value;
            const routeId = routeSelect.value;
            const date = deliveryDate.value;

            if (!sellerId || !routeId || !date) return;

            // First check if a delivery order already exists
            fetch(`/api/check-existing-delivery-order/?route_id=${routeId}&seller_id=${sellerId}&delivery_date=${date}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.exists) {
                        console.log('Existing order found:', data);
                        // Populate form with existing order data
                        const order = data.order;

                        // Set form values
                        document.getElementById('paymentMethod').value = order.payment_method;
                        document.getElementById('notes').value = order.notes || '';
                        document.getElementById('amountCollected').value = order.amount_collected;
                        document.getElementById('totalAmount').value = order.total_price;
                        document.getElementById('openingBalance').value = order.opening_balance;
                        document.getElementById('totalBalance').value = order.total_balance;

                        // Set order items
                        orderItems = data.items;
                        updateOrderItemsTable();
                        if (orderItemsSection) {
                            orderItemsSection.style.display = 'block';
                        }

                        // Show edit message
                        const alertDiv = document.createElement('div');
                        alertDiv.id = 'editingAlert';
                        alertDiv.className = 'alert alert-info mt-2';
                        alertDiv.innerHTML = `Editing existing order <strong>${order.order_number}</strong>`;

                        // Remove any existing alert
                        const existingAlert = document.getElementById('editingAlert');
                        if (existingAlert) {
                            existingAlert.remove();
                        }

                        document.querySelector('.modal-body').insertBefore(alertDiv, document.querySelector('.modal-body').firstChild);

                        // Update form action to edit instead of create
                        document.getElementById('deliveryOrderForm').action = `/delivery/orders/${order.id}/edit/`;

                        // Load available products from loading order
                        return fetch(`/api/routes/${routeId}/available-products/?date=${date}`);
                    } else {
                        console.log(`Fetching opening balance for seller ${sellerId} and date ${date}`);

                        // First, fetch the opening balance for this seller
                        return fetch(`/api/sellers/${sellerId}/opening-balance/?date=${date}`)
                            .then(response => {
                                console.log(`Opening balance API response status: ${response.status}`);
                                if (!response.ok) {
                                    console.warn(`Could not fetch opening balance: ${response.statusText}`);
                                    return { status: 'error', opening_balance: 0 };
                                }
                                return response.json();
                            })
                            .then(balanceData => {
                                console.log(`Opening balance API response data:`, balanceData);

                                // Set the opening balance
                                if (balanceData.status === 'success') {
                                    const openingBalance = balanceData.opening_balance;
                                    console.log(`Setting opening balance to ${openingBalance}`);
                                    document.getElementById('openingBalance').value = openingBalance;
                                    updateTotals(); // Update totals to reflect the new opening balance
                                } else {
                                    console.warn(`Opening balance API returned error: ${balanceData.error || 'Unknown error'}`);
                                    document.getElementById('openingBalance').value = 0;
                                }

                                // Then, load sales order items
                                console.log(`Fetching sales items for seller ${sellerId}, route ${routeId}, and date ${date}`);
                                return fetch(`/api/sales-items/?seller=${sellerId}&route=${routeId}&date=${date}`);
                            })
                            .catch(error => {
                                console.error(`Error fetching opening balance: ${error.message}`);
                                document.getElementById('openingBalance').value = 0;

                                // Continue with sales items even if opening balance fails
                                return fetch(`/api/sales-items/?seller=${sellerId}&route=${routeId}&date=${date}`);
                            })
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error('Network response was not ok');
                                }
                                return response.json();
                            })
                            .then(data => {
                                orderItems = data.items.map(item => ({
                                    product_id: item.product_id,
                                    product_name: item.product_name,
                                    ordered_quantity: item.quantity,
                                    extra_quantity: 0,  // Initialize extra_quantity to 0
                                    delivered_quantity: item.quantity,
                                    unit_price: item.unit_price,
                                    total: item.quantity * item.unit_price
                                }));
                                updateOrderItemsTable();
                                if (orderItemsSection) {
                                    orderItemsSection.style.display = 'block';
                                }

                                // Load available products from loading order
                                return fetch(`/api/routes/${routeId}/available-products/?date=${date}`);
                            });
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    availableProducts = data.products || [];
                })
                .catch(error => {
                    console.error('Error:', error);
                    if (orderItemsSection) {
                        orderItemsSection.style.display = 'none';
                    }
                });
        }

        sellerSelect.addEventListener('change', loadOrderItems);
        deliveryDate.addEventListener('change', loadOrderItems);

        // Update order items table
        function updateOrderItemsTable() {
            console.log('Updating order items table with items:', orderItems);

            // Get the order items body element
            const orderItemsBody = document.getElementById('orderItemsBody');

            if (!orderItemsBody) {
                console.error('orderItemsBody element not found!');
                return;
            }

            console.log('Found orderItemsBody element:', orderItemsBody);

            orderItemsBody.innerHTML = orderItems.map(item => {
                // Calculate available quantity for extra
                const orderedQty = parseFloat(item.ordered_quantity) || 0;
                const extraQty = parseFloat(item.extra_quantity) || 0;
                const availableQty = 100; // Default to a high value if not available

                return `
                <tr>
                    <td>${item.product_name}</td>
                    <td>${item.ordered_quantity}</td>
                    <td>
                        <input type="number"
                               class="form-control form-control-sm"
                               value="${extraQty}"
                               data-product-id="${item.product_id}"
                               data-ordered-qty="${orderedQty}"
                               min="0"
                               max="${Math.max(0, availableQty)}"
                               onchange="updateExtraQuantity('${item.product_id}', this.value)">
                    </td>
                    <td>${parseFloat(orderedQty) + parseFloat(extraQty)}</td>
                    <td>${item.unit_price}</td>
                    <td>${((parseFloat(orderedQty) + parseFloat(extraQty)) * parseFloat(item.unit_price)).toFixed(2)}</td>
                </tr>
                `;
            }).join('');
        }

        // Add new product
        addItemBtn.addEventListener('click', function() {
            // Check if route and date are selected
            if (!routeSelect.value || !deliveryDate.value) {
                alert('Please select route and delivery date first');
                return;
            }

            // Fetch available products from loading order
            const routeId = routeSelect.value;
            const date = deliveryDate.value;

            // Fetch available products from loading order
            fetch(`/api/routes/${routeId}/available-products/?date=${date}`)
                .then(response => response.json())
                .then(data => {
                    availableProducts = data.products || [];
                    console.log('Available products from loading order:', availableProducts);

                    if (availableProducts.length === 0) {
                        alert('No available products found in the loading order for this route and date.');
                        return;
                    }

                    console.log('Available products:', availableProducts);

                    populateProductDropdown();

                    // Show product selection modal
                    const addProductModal = new bootstrap.Modal(document.getElementById('addProductModal'));
                    addProductModal.show();
                })
                .catch(error => {
                    console.error('Error fetching available products:', error);
                    alert('Error loading available products. Please try again.');
                });
        });

        // Populate product dropdown
        function populateProductDropdown() {
            const productSelect = document.getElementById('productSelect');
            productSelect.innerHTML = '<option value="">Select a product</option>';

            // Filter out products that are already in the order
            const usedProductIds = orderItems.map(item => item.product_id);
            const availableForAdd = availableProducts.filter(p => !usedProductIds.includes(p.id));

            availableForAdd.forEach(product => {
                const option = document.createElement('option');
                option.value = product.id;
                option.textContent = `${product.name} (Loaded: ${product.loaded_quantity}, Available: ${product.available_quantity})`;

                // Store available quantity in dataset
                option.dataset.availableQuantity = product.available_quantity;

                // Get price from default price plan or use 0
                // We'll need to fetch this from the server or use a default
                fetch(`/api/products/${product.id}/price/`)
                    .then(response => response.json())
                    .then(data => {
                        option.dataset.price = data.price || '0.00';
                    })
                    .catch(() => {
                        option.dataset.price = '0.00';
                    });

                productSelect.appendChild(option);
            });
        }

        // Handle add product confirmation
        document.getElementById('confirmAddProduct').addEventListener('click', function() {
            const productSelect = document.getElementById('productSelect');
            const productQuantity = document.getElementById('productQuantity');

            if (!productSelect.value) {
                alert('Please select a product');
                return;
            }

            if (!productQuantity.value || parseFloat(productQuantity.value) <= 0) {
                alert('Please enter a valid quantity');
                return;
            }

            const selectedOption = productSelect.options[productSelect.selectedIndex];
            const availableQuantity = parseFloat(selectedOption.dataset.availableQuantity || 0);
            const requestedQuantity = parseFloat(productQuantity.value);

            // Check if requested quantity is within available quantity
            if (requestedQuantity > availableQuantity) {
                alert(`Cannot add more than available quantity (${availableQuantity})`);
                return;
            }

            const productId = productSelect.value;
            const productName = selectedOption.textContent;
            const quantity = parseFloat(productQuantity.value);
            const unitPrice = parseFloat(selectedOption.dataset.price || '0.00');

            // Add to order items
            orderItems.push({
                product_id: productId,  // This should be a string or number that can be converted to an integer
                product_name: productName,
                ordered_quantity: quantity,
                extra_quantity: 0,  // Initialize extra_quantity to 0
                delivered_quantity: quantity,
                unit_price: unitPrice,
                total: quantity * unitPrice
            });

            console.log('Added product to order items:', {
                product_id: productId,
                product_name: productName,
                ordered_quantity: quantity,
                extra_quantity: 0,
                delivered_quantity: quantity,
                unit_price: unitPrice
            });

            // Update the table
            updateOrderItemsTable();

            // Update totals
            updateTotals();

            // Close the modal
            bootstrap.Modal.getInstance(document.getElementById('addProductModal')).hide();

            // Reset form
            productSelect.value = '';
            productQuantity.value = '';
        });

        // Update extra quantity
        window.updateExtraQuantity = function(productId, extraQty) {
            const item = orderItems.find(item => item.product_id === productId);
            if (item) {
                // Parse values
                extraQty = parseFloat(extraQty) || 0;
                const orderedQty = parseFloat(item.ordered_quantity) || 0;

                // Ensure extra quantity is not negative
                if (extraQty < 0) {
                    extraQty = 0;
                }

                // Update the item
                item.extra_quantity = extraQty;

                // Calculate delivered quantity as ordered + extra
                const deliveredQty = orderedQty + extraQty;
                item.delivered_quantity = deliveredQty;

                // Update total
                item.total = deliveredQty * parseFloat(item.unit_price);

                console.log(`Updated item ${item.product_name}: ordered=${orderedQty}, extra=${extraQty}, delivered=${deliveredQty}, total=${item.total}`);

                // Update the table and totals
                updateOrderItemsTable();
                updateTotals();
            }
        };

        // Keep for backward compatibility
        window.updateDeliveredQuantity = function(productId, quantity) {
            console.warn('updateDeliveredQuantity is deprecated, use updateExtraQuantity instead');
            // Calculate extra quantity as the difference between delivered and ordered
            const item = orderItems.find(item => item.product_id === productId);
            if (item) {
                const newDeliveredQty = parseFloat(quantity);
                const orderedQty = parseFloat(item.ordered_quantity);
                const extraQty = Math.max(0, newDeliveredQty - orderedQty);

                // Call the new function
                updateExtraQuantity(productId, extraQty);
            }
        };

        // Update totals
        function updateTotals() {
            // Calculate total from order items
            const itemsTotal = orderItems.reduce((sum, item) => sum + (item.delivered_quantity * item.unit_price), 0);
            console.log(`Items total: ${itemsTotal}`);

            // Set the total amount input (this is just the items total, not including opening balance)
            totalAmountInput.value = itemsTotal.toFixed(2);

            // Get opening balance and amount collected
            const openingBalance = parseFloat(document.getElementById('openingBalance').value) || 0;
            const amountCollected = parseFloat(amountCollectedInput.value) || 0;

            console.log(`Opening balance: ${openingBalance}, Amount collected: ${amountCollected}`);

            // Calculate total balance (opening balance + items total - amount collected)
            const totalBalance = openingBalance + itemsTotal - amountCollected;
            console.log(`Total balance: ${totalBalance} = ${openingBalance} + ${itemsTotal} - ${amountCollected}`);

            // Set the total balance input
            totalBalanceInput.value = totalBalance.toFixed(2);

            // Calculate and set the balance amount (items total - amount collected)
            const balanceAmount = itemsTotal - amountCollected;
            console.log(`Balance amount: ${balanceAmount} = ${itemsTotal} - ${amountCollected}`);

            // Create or update the hidden balance_amount input
            let balanceAmountInput = document.getElementById('balanceAmount');
            if (!balanceAmountInput) {
                balanceAmountInput = document.createElement('input');
                balanceAmountInput.type = 'hidden';
                balanceAmountInput.id = 'balanceAmount';
                balanceAmountInput.name = 'balance_amount';
                document.getElementById('deliveryOrderForm').appendChild(balanceAmountInput);
            }
            balanceAmountInput.value = balanceAmount.toFixed(2);
        }

        // Handle amount collected changes
        amountCollectedInput.addEventListener('input', updateTotals);

        // Form submission
        deliveryOrderForm.addEventListener('submit', function(e) {
            e.preventDefault();

            // Validate form
            // Check if we're in edit mode (disabled fields)
            const isEditMode = routeSelect.disabled || sellerSelect.disabled || deliveryDate.disabled;

            // Only validate enabled fields
            if (!isEditMode && (!routeSelect.value || !sellerSelect.value || !deliveryDate.value)) {
                alert('Please fill in all required fields');
                return;
            }

            if (orderItems.length === 0) {
                alert('No items to deliver');
                return;
            }

            try {
                // Set the items data in the hidden input field
                document.getElementById('itemsData').value = JSON.stringify(orderItems);

                // If we're in edit mode, make sure disabled fields are included
                if (isEditMode) {
                    // Re-enable disabled fields temporarily to include them in the form data
                    const disabledFields = [];

                    if (routeSelect.disabled) {
                        routeSelect.disabled = false;
                        disabledFields.push(routeSelect);
                    }

                    if (sellerSelect.disabled) {
                        sellerSelect.disabled = false;
                        disabledFields.push(sellerSelect);
                    }

                    if (deliveryDate.disabled) {
                        deliveryDate.disabled = false;
                        disabledFields.push(deliveryDate);
                    }
                }

                // Get form data after potentially re-enabling fields
                const formData = new FormData(this);

                // Disable the fields again if in edit mode
                if (isEditMode) {
                    if (routeSelect.value) routeSelect.disabled = true;
                    if (sellerSelect.value) sellerSelect.disabled = true;
                    if (deliveryDate.value) deliveryDate.disabled = true;
                }

                // Add sales order ID if available
                if (salesOrderId) {
                    formData.append('sales_order_id', salesOrderId);
                }

                console.log('Form data prepared, submitting...');
                console.log('Route ID:', routeSelect.value);
                console.log('Seller ID:', sellerSelect.value);
                console.log('Delivery Date:', deliveryDate.value);
                console.log('Items:', orderItems);

                // Submit the form
                fetch(this.action, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': '{{ csrf_token }}'
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.status === 'success') {
                        // Close modal and refresh page
                        const modal = bootstrap.Modal.getInstance(document.getElementById('createDeliveryOrderModal'));
                        modal.hide();
                        location.reload();
                    } else {
                        // Show error message
                        const errorMessage = data.error || 'An error occurred';
                        alert(errorMessage);
                        console.error('Error creating delivery order:', errorMessage);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred. Please try again.');
                });
            } catch (error) {
                console.error('Error in form submission:', error);
                alert('An error occurred while preparing the form data. Please try again.');
            }
        });
    });
    </script>